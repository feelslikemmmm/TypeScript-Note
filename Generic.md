## Generic

C#과 Java 같은 언어에서 재사용 가능한 컴포넌트를 생성하는 도구 상자의 주요 도구 중 하나는 제네릭입니다

즉 단일 타입이 아닌 다양한 타입에서 작동하는 컴포넌트를 작성할 수 있는데요,

사용자는 제네릭을 통해 여러 타입의 컴포넌트나 자신만의 타입을 사용할 수 있습니다

인수로 무엇이 오던 그대로 반환하는 함수를 작성해보겠습니다.

만약 제네릭이 없다면 예시 함수에 특정 타입을 주어야 합니다

![](<https://images.velog.io/images/feelslikemmmm/post/0ab964d7-f4dc-4a4b-a176-1775fcb5bf90/carbon%20(88).png>)

또는 any 타입을 사용해서 이 함수를 기술할 수도 있는데요

![](<https://images.velog.io/images/feelslikemmmm/post/459b0a70-91ab-4f2e-94a3-f3b5078c6789/carbon%20(89).png>)

any를 쓰는 것은 함수의 arg 가 어떤 타입이든 받을 수 있다는 점을 고려하면 제네릭이지만

실제로 함수가 반환할 때 어떤 타입인지에 대한 정보를 잃게됩니다.

만약 number 타입을 넘긴다고 해도 any 타입이 반환된다는 정보만 얻을 수 있습니다

여기서 우리는 무엇이 반환되는지 표시하기 위해서 인수의 타입을 캡처할 방법이 필요한데요,

여기서는 값이 아닌 타입에 적용되는 타입 변수를 사용할 수 있습니다

![](<https://images.velog.io/images/feelslikemmmm/post/ddeb8de5-4aa6-43bf-8c22-46fe01d0a825/carbon%20(90).png>)

예시 함수에 T라는 타입 변수를 추가했습니다 T는 유저가 준 인수의 타입을 캡쳐하고 이 정보를 나중에 사용할 수 있게 하는데요

여기에서는 T를 다시 반환 타입으로 사용합니다

인수와 반환 타입이 같은 타입을 사용하고 있는 것을 확인할 수 있습니다

이를 통해서 타입 정보를 함수의 한쪽에서 다른 한쪽으로 운반할 수 있게끔 합니다

이 함수는 타입을 불문하고 동작하기 때문에 제네릭이라 할 수 있습니다

any 를 사용했을때와는 다르게 타입에 대한 정보를 잃어버리지 않기 때문에 아주 정확합니다.

예시에서 작성한 함수를 호출하는 방법은 두 가지 인데요

![](<https://images.velog.io/images/feelslikemmmm/post/2a34f239-23f3-45b5-ba3e-48a7ea27dfed/carbon%20(91).png>)

첫번째 방법은 위와 같이 함수에 타입 인수를 포함한 모든 인수를 전달하는 방법입니다

함수를 호출할 때의 인수로 T를 string으로 명시해주고 인수를 () 대신 <> 로 감싸주었습니다

![](<https://images.velog.io/images/feelslikemmmm/post/229ae417-7fd9-4ba9-9935-36dd963f2069/carbon%20(92).png>)

두번째 방법은 가장 일반적인 방법입니다

타입 추론을 사용하는 건데요, 우리가 전달하는 인수에 따라 컴파일러가 T의 값을 자동으로 정하게 하는 겁니다

인수의 값인 "myString"을 보고 컴파일러가 그것의 타입으로 T를 정합니다

타입추론으로 코드를 간결하고 가독성 있게 하는데 있어서 유용하지만 ,

복잡한 상황에서는 타입을 유추할 수 없는 경우가 생기기 때문에

명시적인 타입 인수 전달이 필요할 수도 있습니다
